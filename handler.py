import hashlib
import json
import logging
import os
import random
import re
import sqlite3

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, Bot
from telegram.ext import Updater, MessageHandler, Filters, CallbackContext, CallbackQueryHandler, ChatMemberHandler

DB_NAME = './db/tobedo.sqlite3'

CHECK_CHAR = '✅'
UNCHECK_CHAR = '⬜'
TODO_MESSAGE = ["Нажмите на квадратик, что бы поставить галочку:",
                "Не забудьте:",
                "Это важно:",
                "Было бы неплохо это сделать:"]

logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s [%(name)s:%(lineno)s] %(message)s')
LOGGER = logging.getLogger(__name__)


def gen_db():
    # table: Replies
    # message_and_chat_id, reply_id, created_at
    # unique index on message_id
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            CREATE TABLE IF NOT EXISTS Replies (
                message_and_chat_id VARCHAR(255) NOT NULL,
                reply_and_chat_id VARCHAR(255) NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                state TEXT,
                PRIMARY KEY (message_and_chat_id),
                UNIQUE (reply_and_chat_id)
            )
        ''')

        db.commit()


def cleanup_old_replies():
    # delete posts older then 1 year
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            DELETE FROM Replies WHERE created_at < datetime('now', '-1 year')
        ''')

        db.commit()


def get_reply_by_message_id(message_id, chat_id) -> tuple:
    with sqlite3.connect(DB_NAME) as db:
        cursor = db.execute('''
            SELECT reply_and_chat_id, state FROM Replies WHERE message_and_chat_id = ?
        ''', (f"{chat_id}_{message_id}",))

        row = cursor.fetchone()
        if not row:
            return None, None
        return row[0], json.loads(row[1]) if row[1] else {}


def insert_reply(message_id, reply_id, chat_id):
    with sqlite3.connect(DB_NAME) as db:
        db.execute(
            '''
            INSERT INTO Replies (message_and_chat_id, reply_and_chat_id, state) VALUES (?, ?, ?)
            ''',
            (f"{chat_id}_{message_id}", f"{chat_id}_{reply_id}", "{}")
        )

        db.commit()


def update_reply(reply_id, chat_id, state: dict):
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            UPDATE Replies SET state = ? WHERE reply_and_chat_id = ?
        ''',
                   (json.dumps(state), f"{chat_id}_{reply_id}"))

        db.commit()


TOKEN = os.environ.get('TG_TOKEN')
if not TOKEN:
    print('TG_TOKEN not specified in env, please set TG_TOKEN with your bot token generated by @BotFather')
    exit(1)

BOT = Bot(TOKEN)


def button_click(update, context):
    query = update.callback_query

    if query.data.startswith('toggle__'):
        index = query.data.replace('toggle__', '')

        if not query.message.reply_markup:
            print(f'no reply_markup for message_id {query.message.message_id} and chat_id {query.message.chat_id}')
            return

        for i, btn in enumerate(query.message.reply_markup.inline_keyboard):
            checked = btn[0].text.startswith(CHECK_CHAR)
            btn_text = btn[0].text.replace(f'{UNCHECK_CHAR} ', '').replace(f'{CHECK_CHAR} ', '')
            if i == int(index):
                LOGGER.info('found a btn %s', btn_text)
                new_text = f'{CHECK_CHAR} {btn_text}' if not checked else f'{UNCHECK_CHAR} {btn_text}'
                btn[0].text = new_text
                break

        state = {}
        for btn in query.message.reply_markup.inline_keyboard:
            checked = btn[0].text.startswith(CHECK_CHAR)
            btn_text = btn[0].text.replace(f'{UNCHECK_CHAR} ', '').replace(f'{CHECK_CHAR} ', '')
            state[btn_text] = checked

        LOGGER.info('setting state %s', state)
        reply_id = query.message.message_id
        update_reply(reply_id, query.message.chat_id, state)

        context.bot.edit_message_text(
            chat_id=query.message.chat_id,
            message_id=query.message.message_id,
            text=query.message.text,
            reply_markup=query.message.reply_markup
        )


def get_bot_info():
    return BOT.get_me()


def echo(update: Update, context: CallbackContext) -> None:
    """
    This function would be added to the dispatcher as a handler for messages coming from the Bot API
    """

    msg = None
    update_object = None

    if update.channel_post:
        msg = update.channel_post.text
        update_object = update.channel_post
    elif update.message:
        msg = update.message.text
        update_object = update.message
    elif update.edited_message:
        msg = update.edited_message.text
        update_object = update.edited_message

    elif update.edited_channel_post:
        msg = update.edited_channel_post.text
        update_object = update.edited_channel_post

    if not msg:
        LOGGER.info('Unrecognized update')
        return

    is_update = update.edited_message or update.edited_channel_post
    previous_state = {}
    if is_update:
        message_id = update_object.message_id
        reply_id_with_message_id, previous_state = get_reply_by_message_id(message_id, update_object.chat_id)
        if not reply_id_with_message_id:
            LOGGER.info(f'reply_id for message_id {message_id} and chat_id {update_object.chat_id} not found')
            return

    lines = msg.split('\n')
    keyboard = []

    index = 0
    for line in lines:
        ll = line.replace('@'+get_bot_info().username, '')
        line_strip = ll.strip()
        if line_strip == '':
            continue

        LOGGER.info('previous_state %s', previous_state)

        keyboard.append([InlineKeyboardButton(
            f"{CHECK_CHAR if previous_state.get(line_strip, False) else UNCHECK_CHAR} {line_strip}",
            callback_data=f"toggle__{index}"
        )])
        index += 1

    reply_markup = InlineKeyboardMarkup(keyboard)

    bot_name_pattern = re.compile('@'+get_bot_info().username)
    if not is_update:
        if re.search(bot_name_pattern, msg):
            # add new reply
            reply = update_object.reply_text(random.choice(TODO_MESSAGE), reply_markup=reply_markup)
            reply_id = reply.message_id
            message_id = update_object.message_id
            chat_id = update_object.chat_id
            insert_reply(message_id, reply_id, chat_id)

    else:

        # find previous reply to same message and edit it
        # this is a workaround for editing messages in channels
        #
        reply_id = reply_id_with_message_id.split('_')[1]
        context.bot.edit_message_reply_markup(
            chat_id=update_object.chat_id,
            message_id=reply_id,
            reply_markup=reply_markup
        )


def banner():
    bold = "\033[1m"
    purple = '\033[95m'
    cyan = '\033[96m'
    darkcyan = '\033[36m'
    blue = '\033[94m'
    green = '\033[92m'
    yellow = '\033[93m'
    red = '\033[91m'
    underline = '\033[4m'
    end = "\033[0m"
    bot_info = get_bot_info()
    print(purple+"ToDoEx Bot".center(80, '-')+end)
    print(bold+"Version: "+end+"1.0")
    print(bold+"can_read_all_group_messages: "+end+str(bot_info.can_read_all_group_messages))
    print(bold+"supports_inline_queries: "+end+str(bot_info.supports_inline_queries))
    print(bold+"id: "+end+str(bot_info.id))
    print(bold+"can_join_groups: "+end+str(bot_info.can_join_groups))
    print(bold+"first_name: "+end+str(bot_info.first_name))
    print(bold+"is_bot: "+end+str(bot_info.is_bot))
    print(bold+"username: "+end+str(bot_info.username))
    print(purple+"".center(80, '-')+end)


def main() -> None:
    banner()
    gen_db()
    cleanup_old_replies()
    updater = Updater(TOKEN)

    # Get the dispatcher to register handlers
    # Then, we register each handler and the conditions the update must meet to trigger it
    dispatcher = updater.dispatcher
    dispatcher.add_handler(CallbackQueryHandler(button_click))
    # Echo any message that is not a command
    dispatcher.add_handler(MessageHandler(~Filters.command, echo))

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C
    updater.idle()


if __name__ == '__main__':
    main()
